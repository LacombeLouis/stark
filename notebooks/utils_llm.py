from utils_neo4j import Neo4jApp
import os

from typing import List, Optional
from dotenv import load_dotenv

from tqdm import tqdm
from utils_prompt_templates import entity_extraction, relations_extraction
from utils_graph_rag import format_ids_output, get_combinations, format_paths, format_links, limit_paths, check_kg_ids, limit_ids
from llama_index.llms.openai import OpenAI
from utils_neo4j import Neo4jApp


load_dotenv()

os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

class GraphRAG():
    def __init__(
        self,
        graph: Neo4jApp = None,
        llm = OpenAI(model="gpt-3.5-turbo", temperature=0.0),
        show: bool = False
    ):
        self.graph = graph
        self.llm = llm
        self.show = show


    def ask_question(
            self,
            question: str,
            context: str = "",
            show: bool = False
    ):
        """
        Prompt to be asked to the language model

        Args:
            question (str) : The question to be asked to the language model
            context (str) :The context to be provided to the language model
            llm (openai.ChatCompletion) : The language model to be used to generate the response

        Returns:
            str : The response generated by the language model
        """

        prompt = f"""
        You are a researcher working on a project to answer questions about a given context.
        You answer the questions by listing the entities that could answer the question.
        It's key to provide the most relevant entities to the question only given the context.
        The context provided is given as the links between entities in a graph, with the entities being the nodes and the links being the edges.

        Question: {question}
        Context: \n{context}
        """

        if show:
            print(prompt)

        # Generate the response using a method from the OpenAI class
        response = self.llm.complete(prompt)
        return response.text


    def find_ids(self, entities):
        """
        Find the ids of the entities in the knowledge graph

        Args:
            entities (List[str]) : The entities as english word to find the ids of

        Returns:
            List[List[str]] : The ids of the entities in the knowledge graph
        """
        kg_ids = []
        # query_template = "MATCH (e) WHERE trim(toLower(e.name)) CONTAINS trim(toLower({word})) RETURN e"
        query_template = "MATCH (e) WHERE toLower(e.name) =~ '(?i).*\\\\b' + toLower({word}) + '\\\\b.*' RETURN e"

        for entity in entities:
            word = f"'{entity}'"
            query = query_template.format(word=word)  
            try:
                output = self.graph.query(query)
                list_ids = format_ids_output(output)
                kg_ids.append(list_ids)
            except:
                print("No ID found for entity: ", entity)
        return kg_ids


    def get_paths(self, kg_ids, max_distance=50):
        """
        Get the paths between the entities in the knowledge graph

        Args:
            kg_ids (List[List[str]]) : The ids of the entities in the knowledge graph
            max_distance (int) : The maximum distance to search for paths

        Returns:
            List[str] : The paths between the entities in the knowledge graph
        """
        paths_ = []
        query_template = """
            MATCH (e1:Entity), (e2:Entity),
            p = shortestPath((e1)-[*..{max_distance}]-(e2))
            WHERE elementId(e1) = "{node_id1}" AND elementId(e2) = "{node_id2}"
            WITH [node IN nodes(p) | node.name] AS nodes, [rel IN relationships(p) | type(rel)] AS rels
            WITH apoc.coll.flatten(apoc.coll.zip(nodes, rels + [""])) AS elements
            RETURN apoc.text.join(elements[0..-1], " -> ") AS answer
        """
        all_combinations = get_combinations(kg_ids)

        for item in tqdm(all_combinations, total=len(all_combinations)):
            node_id1, node_id2 = item
            query = query_template.format(node_id1=node_id1, node_id2=node_id2, max_distance=max_distance)
            try:
                results = self.graph.query(query)
                paths_.extend([results[0][0]["answer"]])
            except:
                if self.show:
                    print("Error in query")
        return paths_


    def get_links(self, entity):
        """
        Get the links of the entities in the knowledge graph

        Args:
            entity (List[str]) : The entities in the knowledge graph

        Returns:
            List[str] : The links of the entities in the knowledge graph
        """
        list_output = []
        print(entity)
        query_template = """
        MATCH (e1:Entity)-[rel]->(connected)
        WHERE elementId(e1) = '{entity}'
        RETURN e1.name + ' -> ' + type(rel) + ' -> ' + connected.name AS answer
        """
        for item in entity:
            query = query_template.format(entity=item)
            response = self.graph.query(query)
            list_output.extend([entry['answer'] for entry in response[0]])
        return list_output


    def query_engine(self, question: str):
        # Getting entities
        entities = entity_extraction(question)
        print("Entities: ", entities)

        # Getting relations
        relations = relations_extraction(question)

        # Getting ids
        list_ids = self.find_ids(entities)
        list_ids = limit_ids(list_ids, show=self.show)

        if check_kg_ids(list_ids):
            paths_ = self.get_paths(list_ids)
            if relations:
                paths_ = limit_paths(paths_, relations, limit=350)
            context = format_paths(paths_)
        else:
            list_outputs = self.get_links(list_ids[0])
            context = format_links(list_outputs)
        return self.ask_question(question, context, self.show)
