from utils_neo4j import Neo4jApp
import os

from typing import List, Optional
from dotenv import load_dotenv

from tqdm import tqdm
from utils_prompt_templates import entity_extraction, relation_extraction, relation_extraction_score, question_pydantic, format_prompt_final_question
from utils_graph_rag import format_ids_output, get_combinations, format_paths, format_links, limit_paths, check_kg_ids, limit_ids, limit_links
from llama_index.llms.openai import OpenAI
from utils_neo4j import Neo4jApp


load_dotenv()

os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

class GraphRAG():
    def __init__(
        self,
        graph: Neo4jApp = None,
        llm = OpenAI(model="gpt-3.5-turbo", temperature=0.0),
        relation_score: bool = False,
        pydantic: bool = True,
        show: bool = False
    ):
        self.graph = graph
        self.llm = llm
        self.relation_score = relation_score
        self.pydantic = pydantic
        self.show = show


    def ask_question(
            self,
            question: str,
            context: str = ""
    ):
        """
        Prompt to be asked to the language model

        Args:
            question (str) : The question to be asked to the language model
            context (str) :The context to be provided to the language model
            llm (openai.ChatCompletion) : The language model to be used to generate the response

        Returns:
            str : The response generated by the language model
        """

        prompt = format_prompt_final_question(question, context)

        # if self.show:
        #     print(prompt)

        if self.pydantic:
            # Generate the response using a method from the OpenAI class
            response = question_pydantic(question, context)
            answer_ = response
        else:
            # Generate the response using a method from the OpenAI class
            response = self.llm.complete(prompt)
            answer_ = response.text
        return answer_


    def find_ids(self, entities):
        """
        Find the ids of the entities in the knowledge graph

        Args:
            entities (List[str]) : The entities as english word to find the ids of

        Returns:
            List[List[str]] : The ids of the entities in the knowledge graph
        """
        kg_ids = []
        # query_template = "MATCH (e) WHERE trim(toLower(e.name)) CONTAINS trim(toLower({word})) RETURN e"
        query_template = "MATCH (e) WHERE toLower(e.name) =~ '(?i).*\\\\b' + toLower({word}) + '\\\\b.*' RETURN e"

        for entity in entities:
            word = f"'{entity}'"
            query = query_template.format(word=word)  
            try:
                output = self.graph.query(query)
                list_ids = format_ids_output(output)
                kg_ids.append(list_ids)
            except:
                if self.show:
                    print("No ID found for entity: ", entity)
        return kg_ids


    def get_paths(self, kg_ids, max_distance=50):
        """
        Get the paths between the entities in the knowledge graph

        Args:
            kg_ids (List[List[str]]) : The ids of the entities in the knowledge graph
            max_distance (int) : The maximum distance to search for paths

        Returns:
            List[str] : The paths between the entities in the knowledge graph
        """
        paths_ = []
        query_template = """
            MATCH (e1:Entity), (e2:Entity),
            p = shortestPath((e1)-[*..{max_distance}]-(e2))
            WHERE elementId(e1) = "{node_id1}" AND elementId(e2) = "{node_id2}"
            WITH [node IN nodes(p) | node.name] AS nodes, [rel IN relationships(p) | type(rel)] AS rels
            WITH apoc.coll.flatten(apoc.coll.zip(nodes, rels + [""])) AS elements
            RETURN apoc.text.join(elements[0..-1], " -> ") AS answer
        """
        all_combinations = get_combinations(kg_ids)

        for item in tqdm(all_combinations, total=len(all_combinations), disable=not self.show):
            node_id1, node_id2 = item
            query = query_template.format(node_id1=node_id1, node_id2=node_id2, max_distance=max_distance)
            try:
                results = self.graph.query(query)
                paths_.extend([results[0][0]["answer"]])
            except:
                if self.show:
                    print("Error in query")
        return paths_


    def get_links(self, entity):
        """
        Get the links of the entities in the knowledge graph

        Args:
            entity (List[str]) : The entities in the knowledge graph

        Returns:
            List[str] : The links of the entities in the knowledge graph
        """
        list_output = []
        query_template = """
        MATCH (e1:Entity)-[rel]->(connected)
        WHERE elementId(e1) = '{entity}'
        RETURN e1.name + ' -> ' + type(rel) + ' -> ' + connected.name AS answer
        """
        for item in entity:
            query = query_template.format(entity=item)
            response = self.graph.query(query)
            list_output.extend([entry['answer'] for entry in response[0]])
        return list_output


    def query_engine(self, question: str):
        # Getting entities
        entities = entity_extraction(question)
        if self.show: 
            print("Entities: ", entities)

        # Getting relations
        if self.relation_score:
            relations = relation_extraction_score(question)
        else:
            relations = relation_extraction(question)
        
        if self.show:
            print("Relations: ", relations)

        # Getting ids
        list_ids = self.find_ids(entities)
        list_ids = limit_ids(list_ids, show=self.show)

        if check_kg_ids(list_ids):
            paths_ = self.get_paths(list_ids)
            if relations:
                scores_ = None if not self.relation_score else relations.scores
                relations = relations if not self.relation_score else relations.relations
                paths_ = limit_paths(
                    paths_,
                    relations,
                    scores_,
                    show=self.show
                )
            context = format_paths(paths_)
        else:
            list_outputs = self.get_links(list_ids[0])
            list_outputs = limit_links(list_outputs, show=self.show)
            context = format_links(list_outputs)
        return self.ask_question(question, context)
