from utils_neo4j import Neo4jApp
import os

from typing import List, Optional
from dotenv import load_dotenv

from tqdm import tqdm
from utils_prompt_templates import entity_extraction, relation_extraction, relation_extraction_score, question_pydantic, format_prompt_final_question
from utils_graph_rag import format_ids_output, get_combinations, format_paths, format_links, limit_paths, check_kg_ids, limit_ids, limit_links, find_similar_entity, limit_paths_v2
from llama_index.llms.azure_openai import AzureOpenAI
from utils_neo4j import Neo4jApp
from utils_nlp import get_number_tokens


load_dotenv()

# llm = OpenAI(model=os.getenv("model"), temperature=os.getenv("temperature"))

llm = AzureOpenAI(
    model=os.getenv("model"),
    deployment_name="gpt4o",
    api_key=os.getenv("OPENAI_API_KEY"),
    azure_endpoint=os.getenv("OPENAI_API_ENDPOINT"),
    api_version=os.getenv("OPENAI_API_VERSION"),
    temperature=os.getenv("temperature"),
)

class GraphRAG():
    def __init__(
        self,
        graph: Neo4jApp = None,
        llm = llm,
        relation_score: bool = False,
        add_similarity: bool = False,
        force_link: Optional[bool] = None,
        show: bool = False
    ):
        self.graph = graph
        self.llm = llm
        self.relation_score = relation_score
        self.add_similarity = add_similarity
        self.force_link = force_link
        self.show = show


    def ask_question(
            self,
            question: str,
            context: str = "",
            use_links: bool = False
    ):
        """
        Prompt to be asked to the language model

        Args:
            question (str) : The question to be asked to the language model
            context (str) :The context to be provided to the language model
            llm (openai.ChatCompletion) : The language model to be used to generate the response

        Returns:
            str : The response generated by the language model
        """

        prompt = format_prompt_final_question(question, context, use_links)

        # print("question: ", question)
        # print("number of tokens: ", get_number_tokens(context))
        if self.show:
            print(prompt)

        try:
            response = question_pydantic(question, context, use_links)
        except Exception as e:
            response = [f"Error in response: {e}"]
        return response


    def find_ids(self, entities):
        """
        Find the ids of the entities in the knowledge graph

        Args:
            entities (List[str]) : The entities as english word to find the ids of

        Returns:
            List[List[str]] : The ids of the entities in the knowledge graph
        """
        kg_ids = []
        # query_template = "MATCH (e) WHERE trim(toLower(e.name)) CONTAINS trim(toLower({word})) RETURN e"
        # query_template = "MATCH (e) WHERE toLower(e.name) =~ '(?i).*\\\\b' + toLower({word}) + '\\\\b.*' RETURN e"
        query_template = "MATCH (e) WHERE toLower(e.name) = toLower({word}) RETURN e"


        for entity in entities:
            list_ids = []
            entity = entity.replace("'", " ")
            word = f"'{entity}'"
            query = query_template.format(word=word)  
            try:
                output = self.graph.query(query)
                list_ids = format_ids_output(output)
                # kg_ids.append(list_ids)
                list_ids.extend(format_ids_output(output))
            except:
                if self.show:
                    print("No ID found for entity: ", entity)
            if self.add_similarity:
                try:
                    similar_entities = find_similar_entity(entity, graph=self.graph, k=5)
                    list_ids.extend(similar_entities)
                    # print("list_ids: ", list_ids)
                except:
                    if self.show:
                        print("No similar entities found for entity: ", entity)

            kg_ids.append(list_ids)
        
        # print("KG IDs: ", kg_ids)
        return kg_ids


    def get_paths(self, kg_ids, max_distance=50):
        """
        Get the paths between the entities in the knowledge graph

        Args:
            kg_ids (List[List[str]]) : The ids of the entities in the knowledge graph
            max_distance (int) : The maximum distance to search for paths

        Returns:
            List[str] : The paths between the entities in the knowledge graph
        """
        paths_ = []
        query_template = """
            MATCH (e1:Entity), (e2:Entity),
            p = shortestPath((e1)-[*..{max_distance}]-(e2))
            WHERE elementId(e1) = "{node_id1}" AND elementId(e2) = "{node_id2}"
            WITH [node IN nodes(p) | node.name] AS nodes, [rel IN relationships(p) | type(rel)] AS rels
            WITH apoc.coll.flatten(apoc.coll.zip(nodes, rels + [""])) AS elements
            RETURN apoc.text.join(elements[0..-1], " -> ") AS answer
        """
        all_combinations = get_combinations(kg_ids)

        for item in tqdm(all_combinations, total=len(all_combinations), disable=not self.show):
            node_id1, node_id2 = item
            node_id1 = node_id1.replace("'", " ")
            node_id2 = node_id2.replace("'", " ")
            query = query_template.format(node_id1=node_id1, node_id2=node_id2, max_distance=max_distance)
            try:
                results = self.graph.query(query)
                paths_.extend([results[0][0]["answer"]])
            except:
                if self.show:
                    print("Error in query")
        return paths_


    def get_links(self, entity):
        """
        Get the links of the entities in the knowledge graph

        Args:
            entity (List[str]) : The entities in the knowledge graph

        Returns:
            List[str] : The links of the entities in the knowledge graph
        """
        list_output = []
        query_template = """
        MATCH (e1:Entity)-[rel]->(connected)
        WHERE elementId(e1) = '{entity}'
        RETURN e1.name + ' -> ' + type(rel) + ' -> ' + connected.name AS answer
        """
        def is_list_of_lists(lst):
            return all(isinstance(i, list) for i in lst)

        if is_list_of_lists(entity):
            for list_ in entity:
                for item in list_:
                    query = query_template.format(entity=item)
                    response = self.graph.query(query)
                    list_output.extend([entry['answer'] for entry in response[0]])
        else:
            for item in entity:
                query = query_template.format(entity=item)
                response = self.graph.query(query)
                list_output.extend([entry['answer'] for entry in response[0]])
        return list_output


    def query_engine(self, question: str, return_context: bool = False):
        # Getting entities
        entities = entity_extraction(question)
        if self.show: 
            print("Entities: ", entities)

        # Getting relations
        if self.relation_score:
            relations = relation_extraction_score(question)
            good_relation_score = bool(len(relations.relations) == len(relations.scores))
            if self.show:
                print("Relation Scores bool", good_relation_score)
            if not good_relation_score:
                relations.scores = None
        else:
            relations = relation_extraction(question)
        
        if self.show:
            print("Relations: ", relations)

        # Getting ids
        if self.show:
            print("Finding IDs")
        list_ids = self.find_ids(entities)

        print("len of before limit and question similarity: ", [len(item) for item in list_ids])
        list_ids = limit_ids(list_ids, show=self.show)

        if self.show:
            print("len of before question: ", [len(item) for item in list_ids])

        if self.add_similarity:
            if self.show:
                print("Adding Similarity")
            questions_ids = find_similar_entity(question, graph=self.graph, k=15)
            list_ids.append(questions_ids)

        if self.show:
            print("len of after question: ", [len(item) for item in list_ids])

        use_links = not check_kg_ids(list_ids)
        force_link = self.force_link
        if force_link is not None:
            use_links = force_link

        if self.show:
            print("Using links: ", use_links)
        if use_links:
            if self.show:
                print("Getting links")
            list_outputs = self.get_links(list_ids)
            if self.show:
                print("Limiting links")
            if relations:
                scores_ = None if not self.relation_score else relations.scores
                relations = relations if not self.relation_score else relations.relations

                list_outputs = limit_links(list_outputs, relations, scores_)
            context = format_links(list_outputs)
        else:
            if self.show:
                print("Getting paths")
            paths_ = self.get_paths(list_ids)
            if relations:
                scores_ = None if not self.relation_score else relations.scores
                relations = relations if not self.relation_score else relations.relations
                if self.show:
                    print("Limiting paths")
                paths_ = limit_paths(
                    paths_,
                    relations,
                    scores_,
                    show=self.show
                )
            context = format_paths(paths_)


        if return_context:
            return self.ask_question(question, context, use_links), context
        else:
            return self.ask_question(question, context, use_links)


    # def query_engine_v2(self, question: str, return_context: bool = False):
    #     # Getting entities
    #     entities = entity_extraction(question)
    #     if self.show: 
    #         print("Entities: ", entities)

    #     # relations = relation_extraction(question)
        
    #     # if self.show:
    #     #     print("Relations: ", relations)

    #     # Getting ids
    #     if self.show:
    #         print("Finding IDs")
    #     list_ids = self.find_ids(entities)
    #     list_ids = limit_ids(list_ids, show=self.show)

    #     if self.add_similarity:
    #         if self.show:
    #             print("Adding Similarity")
    #         questions_ids = find_similar_entity(question, graph=self.graph)
    #         list_ids.append(questions_ids)

    #     if self.show:
    #         print("len of: ", [len(item) for item in list_ids])

    #     paths_ = self.get_paths(list_ids)
    #     if self.show:
    #         print("Limiting paths")
    #     paths_ = limit_paths_v2(
    #         question,
    #         paths_,
    #         show=self.show
    #     )
    #     context = format_paths(paths_)

    #     if return_context:
    #         return self.ask_question(question, context), context
    #     else:
    #         return self.ask_question(question, context)
